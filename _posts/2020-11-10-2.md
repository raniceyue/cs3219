---
layout: post
title: The Observer Pattern aka Pub/Sub Pattern
tags:
- Task E
date: 2020-11-10 13:24 +0800
---

The Observer pattern is one of the [Behavioural Patterns](https://en.wikipedia.org/wiki/Behavioral_pattern) (patterns concerning communication between classes/objects) introduced in the famous book [Design Patterns by Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns). It is also known as the Pub/Sub Pattern (Publish Subscribe).

This was a pattern that I had learnt about during one of my tutorial lessons in CS3219, and presented to my classmates in the tutorial. 

## What is does

The Observer pattern is a design pattern where an object (aka subject or publisher) maintains a list of dependencies (observers or subscriber), and automatically notifies its dependencies of any changes to the state.

_For simplicity, I will be using the terms **subject** and **observers** throughout this article._

### Subject and Observers Explained

The subject in this pattern has 3 main objectives
1. Maintains a list of observers
2. Provides methods to add and remove observers from its list of observers
3. Add and notify observers automatically when there are any state changes aka broadcasts all events to registered observers

### Why use the Observer Pattern? 

The advantages of using this powerful design pattern for communication between objects and classes are as follows 

1. **The observers depending on the subject are decoupled from the subject**  
   i.e. it promotes loose coupling between objects that communicate with each other
2. **Observers can be added and removed at any time**  
   without making mchanges to the objects or subjects, offering more flexible and extensible software design that is easy to change and scale depending on your needs
3. Data communication between objects can be implemented without making any changes to the subject or observer classes

All of these benefits from the use of this pattern in a software all align with the good reasons why developer teams use design principles and patters in their code in the first place! To build robust, flexible and reusable software.

## Example

Lets illustrate this pattern with an example! 

Suppose we have a club in NUS that has a mailing list for all its events, which contains a list of students that are subscribed to the mailing list for updates on weekly events hosted by the club. 

Here is a code example to illustrate how this all works in the Observer pattern, where `Club` acts as said club, and `Student` models the students subscribed to the club's mailing list. 

Note that in this case, `Club` acts as the **subject** while `Student` acts as an **observer** in the Observer pattern.

```javascript
//////////////////////////////////
//  SUBJECT CLASS AKA CLUB
//////////////////////////////////

public class Club {
    List<Student> subscribers;
    private Event nextEvent;

    public Club(Event nextEvent) {
        subscribers = new LinkedList();
        setNextEvent(nextEvent);
    }

    public Event getNextEvent() {
        return nextEvent;
    }

    public void setNextEvent(Event nextEvent) {
        this.nextEvent = nextEvent
        System.out.println("NUS Hackers has an upcoming event : " + nextEvent.toString());
        notifySubscribers();
    }

    public void registerSubscribers(Student ... students) {
        for (Student s : students) {
            this.subscribers.add(s);
        }
    }

    public void removeSubscriber(Student student) {
        subscribers.remove(student);
    }

    public void notifySubscribers() {
        for (Student s : subscribers) {
            s.update();
        }
    }
}
```
The above code models a club in NUS, `NUSHackers`. It has methods to set the next upcoming event they are hosting, methods to add and remove students subscribed to their mailing list and a method to notify their subscribers when a next event is announced.

Now let us model a `Student` object using an abstract class. Here we are using an abstract class as we want all our `Student` objects to have the same attributes, they can only be subscribed to one club and they must include an `update()` function to receive updates from the club they are subscribed to.

```javascript
///////////////////////////////////////
//  OBSRVER CLASS AKA STUDENT CLASS
///////////////////////////////////////

public abstract class Student {
    protected Club club;
    public abstract void update();
}
```
Now let us model a subclasses of the `Student` class that represent some students in NUS. 

```javascript
////////////////////////////////////////////
//  2 OBSERVER CLASSES, RANICE & YUCKSUAN
////////////////////////////////////////////

public class Ranice extends Student {

    public Ranice(Club club) {
        this.club = club;
        this.club.registerSubscriber(this);
    }

    public void update() {
        System.out.println("I am excited for my club's next event : " + club.getNextEvent().toString();
    }
}

public class Yucksuan extends Student {

    public Yucksuan(Club club) {
        this.club = club;
        this.club.registerSubscriber(this);
    }

    public void update() {
        System.out.println("I am a FASS student and excited for the next event by the club im subscribed to : " + club.getNextEvent().toString();
    }
}
```

Now let us assume that both of the `Student` observer objects `Ranice` and `Yucksuan` are subscribed to the subject, a `Club` instance called `NUSHackers`. 

Whenever the subject `NUSHackers` makes a change to its state (i.e. makes an announcment for an upcoming event) using the `setNextEvent()` method, the `notifySubscribers()` metohd will be called, notifying all students subscribed to the club's mailing list of any upcoming events to look out for.

Here is a diagram to illustrate what the programs look like (where `Club` represents the object )

<img src="/cs3219/assets/uml-observer1.png">

In technical terms, this is what the program represents which is essentially the Observer Pattern.

<img src="/cs3219/assets/uml-observer2.png">

**Example of Usage**
```javascript
Event welcomeTea = new Event("Welcome Tea");
Club NUSHackers = new Club(welcomeTea)

// Ranice and yucksuan have subscribed to the club /// NUS Hackers that has a welcomeTea event upcoming
Student ranice = new Ranice(NUSHackers);
Student yucksuan = new Yucksuan(NUSHackers);

NUSHackers.notifySubscribers();
Event HacknRoll2021 = new Event("Hack & Roll 2021")
NUSHackers.setState(HacknRoll2021);
```

The output of the above sequence will be as follows
```
NUSHackers has an upcoming event : Welcome Tea
I am excited for my club's next event : Welcome Tea
I am a FASS student and excited for the next event by the club im subscribed to : Welcome Tea
NUSHackers has an upcoming event : Hack & Roll 2021
I am excited for my club's next event : Hack & Roll 2021
I am a FASS student and excited for the next event by the club im subscribed to : Hack & Roll 2021

```

## Conclusion

And that's all about the Observer pattern! It is easy to use, scalable, robust and commonly used in many software programs today. 


