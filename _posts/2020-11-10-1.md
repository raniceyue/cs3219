---
layout: post
title: The Builder Pattern
tags:
- Task E
- patterns
- software engineering
- design
date: 2020-11-10 13:27 +0800
---

The builder pattern is one of the creational patterns introduced in the [Design Patterns by Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns). This was a pattern that I had learnt about during one of my tutorial lessons in CS3219, presented by my classmates. 

## What it does

The builder design pattern (as the name implies) is used in the creation of complex objects in object-oriented software. The main purpose of the bulder pattern is to abstract the process of object creation in the software, into a seperate `Builder` object, i.e. rather than immediately creating the object, object creation is done in steps by the `Builder` object. 

## What's so good about this pattern? And when should I use it?

Often times in object-oriented software, the objects needed in the sofware can vary from simple objects to complex objects containing many paramaters (some of which may even be optional!). Moreover, some of these parameters needed to create the object can comprise of sub-objects. This makes the object to be created very complicated. Sometimes we may even want to build many different variations of a similar object. This makes things very complicated, however, this can be simplified using the builder pattern. 

I will now illustrate with a simple hypothetical example.

## Example

Here is an example scenario. Suppose we are trying to build a `ChristmasTree` object. 

Consider the components in a christmas tree
- christmas trees always have a star at the top
- some might have ball ornaments
- some might have candy canes
- some might have other misc ornaments hanging from the tree like angels and elves

However, the most essential parts of the tree, are the star at the top, and of course, the tree itself. The rest of the components are optional. In this case of building such a complex object, the builder pattern can be implemented. 

Here is an example of how the builder pattern can be implemented for constructing a `ChristmasTree` object via a `ChristmasTreeBuilder` object. 

### Building Our `ChristmasTree`

First, let us define what the `ChristmasTree` object should be like, and how the builder should construct it. 

```java
class ChristmasTree {
    private final Tree tree;
    private final Star star;
    private final Ornaments ornaments;
    private final CandyCanes candyCanes;

    private ChristmasTree(ChristmasTreeBuilder builder) {
        this.tree = tree;
        this.star = star;
        this.ornaments = ornaments;
        this.candyCanes = candyCanes;
    }

    public Tree getTree() {
        return tree;
    }

    public Star getStar() {
        return star;
    }

    public Ornaments getOrnaments() {
        return ornaments;
    }

    public CandyCanes getCandyCanes() {
        return candyCanes;
    }

    /////////////////////////////////////////
    //  THE BUILDER CLASS
    /////////////////////////////////////////

    class ChristmasTreeBuilder {

        private final Tree tree;
        private final Star star;
        private final Ornaments ornaments;
        private final CandyCanes candyCanes;

        // Constructor for builder where essential components are initialized
        public ChristmasTreeBuilder(Tree tree, Star star) {
            this.tree = tree;
            this.star = star;
        }

        public PersonBuilder ornaments(Ornaments ornaments) {
            this.ornaments = ornaments;
            return this;
        }

        public PersonBuilder candyCanes(CandyCanes candyCanes) {
            this.candyCanes = candyCanes;
            return this;
        }

        // Build method to output the final object
        public ChristmasTree build() {
            return new ChristmasTree(this)
        }
    }
}
```

The first thing you would notice, is that the constructor for the object is `private`, and the parameter of the `ChristmasTree` object is a `ChristmasTreeBuilder`.

In accordance to the builder pattern, the build steps for the `ChristmasTree` are abstracted through the use of a `ChristmasTreeBuilder`. This makes it such that the christmas tree can only be built by invoking a `ChristmasTreeBuilder`. 

This is how the `ChristmasTree` will be built, supposing the components have already been created.

```java
ChristmasTree tree = new ChristmasTree.ChristmasTreeBuilder(greenTree, yellowStar)
    .ornaments(redOrnaments)
    .candyCanes(blueCandyCanes)
    .build()
```

The following diagram illustrates how the chain of methods on the `ChristmasTreeBuilder` help to build and add each component to the christmas tree!

![](/assets/tree.png)

From this example, we can clearly see how the building of the tree is simplified as we are able to add and omit certain parameters as per our preference i.e. you can not have `candyCanes` on the `ChristmasTree` if you don't want to!

## In Real Life..

In reality, the implementation of the builder pattern in software is a bit more complex. There are more classes involved to formalize the construction of the desired object. 

<img src="/assets/uml-builder.png" width="600px"/>
[_Source_](design-patterns-stories.com)

The additional classes include the `Director` class, and the actual building process consists of 2 classes, the `Builder` class and the `ConcreteBuilder` class, and finally the `Product` class which is actually the object that we want to build.

Here is an explanation of how these components work together 

**The `Director` Class**
- A reusable class that contains the algorithm to build the `Product`
- It uses the interface provided by the `Builder`
- It basically creates the product

**The `Builder` Class**
- A **general** builder class that should allow any variation of the `ConcreteBulder` class to build their corresponding product.
- It does not have a `getProduct()` method, only an abstract one. 

**The `ConcreteBuilder` Class**
- Builds and assembles all the parts in the object and keeps track of the product and references it
- The final product is obtained from this class via the `getProduct()` method.
- In the previous example, this is the `ChristmasTreeBuilder` class.

**The `Product` Class**
- The actual class of the complex object to be build in the program. 
- In the previous example, this is the `ChristmasTree` object

How these parts work together are like this:

The program first chooses the concrete builder that they need to create the object, and the director needed to build this object. The concrete builder is then injected into the director, and the director's `construct()` method is called and the product is returned by calling the `getProduct()` method of the concrete builder. 

## Conclusion

From here, we are able to see how the builder pattern helps to simplify code design for cases where 
- Objects are complex and cannot be constructed in one method call
- Many different variations of a single object need to be built, that have similar attributes. 

That's all for the builder pattern!
